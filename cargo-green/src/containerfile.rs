use std::{fs, io::ErrorKind};

use anyhow::{anyhow, bail, Result};
use camino::Utf8Path;
use log::{info, trace};

use crate::{hash, image_uri::ImageUri, logging::maybe_log, REPO, VSN};

pub(crate) struct Containerfile {
    script: String,
}

impl Containerfile {
    #[must_use]
    pub(crate) fn with_syntax(syntax: &ImageUri) -> Self {
        let mut header = format!("# syntax={}\n", syntax.noscheme());
        header.push_str("# check=error=true\n");
        header.push_str(&format!("# Generated by {REPO} v{VSN}\n"));
        header.push('\n');
        Self { script: header }
    }

    pub(crate) fn push(&mut self, block: &str) {
        self.script.push_str(block);
    }

    pub(crate) fn pushln(&mut self, block: &str) {
        self.push(block);
        self.nl()
    }

    pub(crate) fn nl(&mut self) {
        self.script.push('\n');
    }

    #[must_use]
    pub(crate) fn hashed(&self) -> String {
        hash(&self.script)
    }

    pub(crate) fn write_to(&self, path: &Utf8Path) -> Result<()> {
        info!("opening (RW) containerfile {path}");

        // TODO? suggest a `cargo clean` then fail
        if maybe_log().is_some() {
            match fs::read_to_string(path) {
                Ok(existing) => pretty_assertions::assert_eq!(&existing, &self.script),
                Err(e) if e.kind() == ErrorKind::NotFound => {}
                Err(e) => bail!("Failed reading {path}: {e}"),
            }
        }

        fs::write(path, &self.script).map_err(|e| anyhow!("Failed creating {path}: {e}"))?;

        let ignore = format!("{path}.dockerignore");
        fs::write(&ignore, "").map_err(|e| anyhow!("Failed creating {ignore}: {e}"))?;

        if maybe_log().is_some() {
            info!("dockerfile: {path}");
            match fs::read_to_string(path) {
                Ok(data) => data,
                Err(e) => e.to_string(),
            }
            .lines()
            .filter(|x| !x.is_empty())
            .for_each(|line| trace!("❯ {line}"));
        }

        Ok(())
    }

    #[must_use]
    pub(crate) fn remove_from(&self, path: &Utf8Path) -> String {
        let _ = fs::remove_file(path);
        let _ = fs::remove_file(format!("{path}.dockerignore"));
        self.script.clone()
    }
}
